/*pgTap function to test register_interaction_http_request function*/

DROP FUNCTION IF EXISTS techbd_udi_assurance.test_register_interaction_http_request(text);
CREATE OR REPLACE FUNCTION techbd_udi_assurance.test_register_interaction_http_request(schema_name text DEFAULT 'techbd_udi_ingress'::text)
 RETURNS SETOF text
 LANGUAGE plpgsql
AS $function$
DECLARE    
    return_value TEXT;
    v_interaction_id TEXT; 
    v_interaction_key TEXT; 
    v_payload jsonb; 
    v_rule_namespace TEXT;
    v_elaboration jsonb; 
    v_nature jsonb; 
    v_content_type TEXT; 
    v_from_state TEXT; 
    v_to_state TEXT; 
    v_state_transition_reason TEXT; 
    v_created_at timestamp; 
    v_created_by TEXT; 
    v_provenance TEXT; 
    v_hub_upsert_behavior boolean;
    v_hub_diagnostic_row techbd_udi_ingress.hub_diagnostic%ROWTYPE;
   	function_exists boolean;
    v_hub_diagnostic_id TEXT;
BEGIN
	
    v_interaction_id            := 'b41ccd27-9a4f-5cc8-9c5d-b55242d90fb0';
    v_interaction_key           := '/Bundle';
    v_elaboration               := '{"key" : "elaboration"}';
    v_nature                    := '{"nature": "org.techbd.service.http.Interactions$RequestResponseEncountered", "tenant_id": "N/A"}';
    v_content_type              := 'application/json';
    v_from_state                := NULL;
    v_to_state                  := NULL;
    v_state_transition_reason   := 'state_transition_reason_1';
    v_created_at                := CURRENT_TIMESTAMP;
    v_created_by                := CURRENT_USER;
    v_provenance                := 'org.techbd.service.http.InteractionsFilter.doFilterInternal';
    v_hub_upsert_behavior       := FALSE;
    v_rule_namespace            := NULL;
    v_hub_diagnostic_id         := NULL;
   
    -- Check if the table 'pgtap_fixtures_json' exists
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'techbd_udi_assurance' 
               AND table_name = 'pgtap_fixtures_json') THEN 
        SELECT "jsonb" INTO v_payload
        FROM techbd_udi_assurance.pgtap_fixtures_json 
        WHERE "name" = 'interaction_payload';
    ELSE 
        RETURN NEXT 'Table techbd_udi_assurance.pgtap_fixtures_json does not exist';
    END IF;
    
    -- Check existence of required functions     
   RETURN NEXT has_function(
        schema_name,
        'register_interaction_http_request',
        -- ARRAY['text', 'text', 'jsonb', 'text', 'text', 'jsonb', 'jsonb', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'timestamptz', 'text', 'text', 'boolean'],
         ARRAY['text', 'text', 'jsonb', 'text', 'text', 'jsonb', 'jsonb', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'timestamptz', 'text', 'text', 'boolean', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text'],
        'Function register_interaction_http_request exists'
    );
    RETURN NEXT has_function(
        schema_name,
        'register_issue',
        ARRAY['text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'jsonb'],
        'Function register_issue exists'
    );
    RETURN NEXT has_function(
        schema_name,
        'sat_interaction_fhir_request_upserted',
        ARRAY['text', 'text', 'text', 'text', 'text', 'text', 'jsonb', 'text', 'timestamptz', 'text', 'text', 'jsonb'],
        'Function sat_interaction_fhir_request_upserted exists'
    );
    /*=================== Testing with FHIR bundle ========================*/
   
    PERFORM techbd_udi_ingress.register_interaction_http_request(
        interaction_id           => v_interaction_id,
        interaction_key          => v_interaction_key,
        payload                  => v_payload,
        payload_text             => NULL,
        rule_namespace           => v_rule_namespace,
        elaboration              => v_elaboration,
        nature                   => v_nature,
        content_type             => v_content_type,
        from_state               => v_from_state,
        to_state                 => v_to_state,
        state_transition_reason  => v_state_transition_reason,
        created_at               => v_created_at,
        created_by               => v_created_by,
        provenance               => v_provenance,
        hub_upsert_behavior      => true
    );
    
    RETURN NEXT ok(
            EXISTS(SELECT 1 FROM techbd_udi_ingress.hub_interaction hub_intr
                            WHERE hub_intr.hub_interaction_id    = v_interaction_id
                            AND hub_intr."key"                   = v_interaction_key
                            AND hub_intr.created_by              = v_created_by
                            AND hub_intr.provenance              = v_provenance
                   ),
            'FHIR Bundle - Successfully inserted into the table hub_interaction'::text
        );

   /*Test one record is inserted into sat_interaction_user table*/
   RETURN NEXT ok(
            EXISTS(SELECT 1 FROM techbd_udi_ingress.sat_interaction_user sat_intr
                            WHERE sat_intr.hub_interaction_id	= v_interaction_id
                            AND sat_intr.uri                    = v_interaction_key
							AND sat_intr.nature 				= v_nature->>'nature'
                            AND sat_intr.created_by				= v_created_by
                            AND sat_intr.provenance				= v_provenance
                   ),
            'FHIR Bundle - Successfully inserted into the table sat_interaction_user'::text
        );
       
	/*===================================================================*/

/*Test 3 raws are inserted into sat_interaction_http_request table*/
-- RETURN NEXT ok(
--         EXISTS (
--             SELECT 1
--             FROM (
--                 SELECT COUNT(*) AS record_count
--                 FROM techbd_udi_ingress.sat_interaction_http_request sat_intr
--                 WHERE sat_intr.hub_interaction_id = v_interaction_id
--                   AND sat_intr.nature_denorm IN (
--                       'org.techbd.service.http.Interactions$RequestResponseEncountered', 
--                       'Original FHIR Payload', 
--                       'techByDesignDisposition'
--                   )
--                   AND sat_intr.created_by = v_created_by
--                   AND sat_intr.provenance = v_provenance
--             ) subquery
--             WHERE subquery.record_count = 3
-- 	    ),
-- 	    'FHIR Bundle - Successfully inserted 3 records into sat_interaction_http_request'
-- 	);


/*Test 3 raws are inserted into sat_interaction_fhir_request table*/
-- RETURN NEXT ok(
--         EXISTS (
--             SELECT 1
--             FROM (
--                 SELECT COUNT(*) AS record_count
--                 FROM techbd_udi_ingress.sat_interaction_fhir_request sat_intr
--                 WHERE sat_intr.hub_interaction_id = v_interaction_id
--                   AND sat_intr.uri = v_interaction_key
--                   AND sat_intr.nature IN (
--                       'org.techbd.service.http.Interactions$RequestResponseEncountered', 
--                       'Original FHIR Payload', 
--                       'techByDesignDisposition'
--                   )
--                   AND sat_intr.created_by = v_created_by
--                   AND sat_intr.provenance = v_provenance
--             ) subquery
--             WHERE subquery.record_count = 3
-- 	    ),
-- 	    'FHIR Bundle - Successfully inserted 3 records into sat_interaction_fhir_request'
-- 	);


	/*Test the exception handling with Unique Constraint Violation*/
       
    PERFORM techbd_udi_ingress.register_interaction_http_request(
        interaction_id           => v_interaction_id,
        interaction_key          => v_interaction_key,
        payload                  => v_payload,
        payload_text             => NULL,
        rule_namespace           => v_rule_namespace,
        elaboration              => v_elaboration,
        nature                   => v_nature,
        content_type             => v_content_type,
        from_state               => v_from_state,
        to_state                 => v_to_state,
        state_transition_reason  => v_state_transition_reason,
        created_at               => v_created_at,
        created_by               => v_created_by,
        provenance               => v_provenance,
        hub_upsert_behavior      => false
    );
         
   	--RETURN NEXT ok(v_hub_diagnostic_row IS NOT NULL, 'Successfully catched the exception and inserted into the table hub_diagnostic');
    RETURN NEXT ok(
    	EXISTS(SELECT 1 
		    FROM techbd_udi_ingress.hub_diagnostic hub_exp
		    WHERE hub_exp."key"      = v_interaction_key
		    AND hub_exp.created_by   = v_created_by
		    AND hub_exp.provenance   = v_provenance LIMIT 1
		), 
		'Successfully catched the exception and inserted into the table hub_diagnostic');
    
    SELECT hub_exp.hub_diagnostic_id INTO v_hub_diagnostic_id
    FROM techbd_udi_ingress.hub_diagnostic hub_exp
    WHERE hub_exp."key"      = v_interaction_key
    AND hub_exp.created_by   = v_created_by
    AND hub_exp.provenance   = v_provenance LIMIT 1;
    
    IF v_hub_diagnostic_id != '' THEN 
	    RETURN NEXT ok(
	            EXISTS((SELECT 1 FROM techbd_udi_ingress.sat_diagnostic_exception sat_exp
	                            WHERE sat_exp.hub_diagnostic_id  = v_hub_diagnostic_id--v_hub_diagnostic_row.hub_diagnostic_id                    
	                            AND sat_exp.created_by           = v_created_by
	                            AND sat_exp.provenance           = v_provenance
	                   ) UNION  
	                   (SELECT 1 FROM techbd_udi_ingress.sat_diagnostic_log sat_log
	                            WHERE sat_log.hub_diagnostic_id  = v_hub_diagnostic_id--v_hub_diagnostic_row.hub_diagnostic_id                    
	                            AND sat_log.created_by           = v_created_by
	                            AND sat_log.provenance           = v_provenance)),
	            'Successfully inserted exception details into the table sat_diagnostic_exception or sat_diagnostic_log'
	        ); 
    END IF;



END;
$function$
;




DROP FUNCTION IF EXISTS techbd_udi_assurance.test_json_action_rule_upsert(text);

CREATE OR REPLACE FUNCTION techbd_udi_assurance.test_json_action_rule_upsert(schema_name text DEFAULT 'techbd_udi_ingress'::text)
 RETURNS SETOF text
 LANGUAGE plpgsql
AS $function$
DECLARE    
    v_payload 				jsonb; 
    v_action_rule_id 		TEXT 		:= NULL;
    v_created_at 			timestamp; 
    v_hub_diagnostic_row 	techbd_udi_ingress.hub_diagnostic%ROWTYPE;
    v_namespace 			TEXT; 
    v_json_path 			TEXT; 
    v_action 				TEXT; 
    v_condition 			jsonb; 
    v_reject_json 			jsonb; 
    v_modify_json 			jsonb; 
    v_priority 				integer; 
    v_updated_by 			TEXT; 
    v_last_applied_at 		timestamp with time zone; 
    v_created_by 			TEXT; 
    v_provenance 			TEXT;
	v_return				TEXT 		:= NULL;
	v_key					TEXT 		:= 'action_rule';
BEGIN
	/**
	* The function techbd_udi_assurance.test_json_action_rule_upsert is designed to perform unit tests on the
	* json_action_rule_upserted function in the techbd_udi_ingress schema. It validates the existence of key functions,
	* checks the correctness of insert and update operations, and tests the handling of exceptions. The function returns
	* detailed messages regarding the success or failure of each test, including checking the insertion of records into the
	* json_action_rule table and verifying exception handling by checking logs in diagnostic tables.
	*/

    v_namespace			:= 'namespace_group_1';
    v_json_path			:= '$.response.responseBody.OperationOutcome.validationResults[*].operationOutcome.issue[*].location[*] ? (@ == "Bundle.entry[0].resource/*Patient/PatientExample*/.extension[2].value.ofType(code)")';
    v_action			:= 'reject';
    v_priority			:= 1;
    v_updated_by		:= CURRENT_USER;
    v_last_applied_at	:= CURRENT_TIMESTAMP;
    v_created_by		:= CURRENT_USER;
    v_provenance		:= '{"Key" : "value"}';	


    -- Check if the table 'pgtap_fixtures_json' exists
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'techbd_udi_assurance' 
               AND table_name = 'pgtap_fixtures_json') THEN 
        SELECT "jsonb" INTO v_condition
        FROM techbd_udi_assurance.pgtap_fixtures_json 
        WHERE "name" = 'json_action_rule_condition';
       
        SELECT "jsonb" INTO v_reject_json
        FROM techbd_udi_assurance.pgtap_fixtures_json 
        WHERE "name" = 'json_action_rule_reject_json';
       
        SELECT "jsonb" INTO v_modify_json
        FROM techbd_udi_assurance.pgtap_fixtures_json 
        WHERE "name" = 'json_action_rule_modify_json';
    ELSE 
        RETURN NEXT 'Table techbd_udi_assurance.pgtap_fixtures_json does not exist';
    END IF;

    -- Check existence of required functions     
    RETURN NEXT has_function(
        schema_name,
        'json_action_rule_upserted',
        ARRAY['text', 'text', 'text', 'text', 'jsonb', 'jsonb', 'jsonb', 'integer', 'text', 'text', 'text'],
        'Function json_action_rule_upserted exists'
    ); 
   
    RETURN NEXT has_function(
        schema_name,
        'register_issue',
        ARRAY['text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'jsonb'],
        'Function register_issue exists'
    );

	
    SELECT techbd_udi_ingress.json_action_rule_upserted(
    	action_rule_id	=> NULL,
    	namespace		=> v_namespace, 
    	json_path		=> v_json_path, 
    	action			=> v_action, 
    	condition		=> v_condition, 
    	reject_json		=> v_reject_json, 
    	modify_json		=> v_modify_json, 
    	priority		=> v_priority, 
    	updated_by		=> v_updated_by, 
    	created_by		=> v_created_by, 
    	provenance		=> v_provenance
    ) INTO v_return;  
   
	RETURN NEXT ok(
			EXISTS(SELECT 1 WHERE v_return IS NOT NULL),
            'Successfully inserted into the table json_action_rule'
        );

   	v_action_rule_id := v_return;
       
   	SELECT techbd_udi_ingress.json_action_rule_upserted(
    	action_rule_id	=> v_action_rule_id,
    	namespace		=> v_namespace, 
    	json_path		=> v_json_path, 
    	action			=> v_action, 
    	condition		=> v_condition, 
    	reject_json		=> v_reject_json, 
    	modify_json		=> v_modify_json, 
    	priority		=> v_priority, 
    	updated_by		=> v_updated_by, 
    	created_by		=> v_created_by, 
    	provenance		=> v_provenance
   ) INTO v_return;  
   
   RETURN NEXT ok(v_action_rule_id = v_return,
            'Successfully updated the table json_action_rule'
        );

   /*Test the exception handling*/
   SELECT techbd_udi_ingress.json_action_rule_upserted(
    	action_rule_id	=> NULL,
    	namespace		=> v_namespace, 
    	json_path		=> v_json_path, 
    	action			=> 'test', 
    	condition		=> v_condition, 
    	reject_json		=> v_reject_json, 
    	modify_json		=> v_modify_json, 
    	priority		=> v_priority, 
    	updated_by		=> v_updated_by, 
    	created_by		=> v_created_by, 
    	provenance		=> '{"Key" : "exception"}' 
    ) INTO v_return; 
   
   SELECT hub_exp.* INTO v_hub_diagnostic_row
   FROM techbd_udi_ingress.hub_diagnostic hub_exp
   WHERE hub_exp."key"      	= v_key
	   AND hub_exp.created_by   = CURRENT_USER
	   AND hub_exp.provenance   = '{"Key" : "exception"}' 
   ;
   
   RETURN NEXT ok(v_hub_diagnostic_row IS NOT NULL, 'Successfully catched the exception and inserted into the table hub_diagnostic'); 
   
   RETURN NEXT ok(
            EXISTS(SELECT 1 FROM techbd_udi_ingress.sat_diagnostic_exception sat_exp
                            WHERE sat_exp.hub_diagnostic_id  = v_hub_diagnostic_row.hub_diagnostic_id                    
                            AND sat_exp.created_by           = CURRENT_USER
                            AND sat_exp.provenance           = '{"Key" : "exception"}'
                   ),
            'Successfully inserted exception details into the table sat_diagnostic_exception'
        );  
END;
$function$
;